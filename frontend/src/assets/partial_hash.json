{"noir_version":"0.33.0+325dac54efb6f99201de9fdeb0a507d45189607d","hash":9727994392226336382,"abi":{"parameters":[],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9Way1LqQBCGE0QcMuES7rA/+wh61J2v4m3hxrIsn83n00lltGk7ZU/Z2JOpogKZ0P833wQSQtLkqx2jZZo0t+t6Wf6yfQv/g9BTjdCtRuhOI/Tss6AL6ybM5sne6qVBfV0pwsvytAcCsJEODDf7+db3g76Tj0evXlW4bc1+PffyCIwjTeR2ZAOyRR2V23ObfJ887Ar298B4jw/CdMjxlqWp59LX7ojVvrhNk/39uQvc+fEMwTYnwKU5kMsUZHsmOIdUvpyT7dbV6zOc9AmmvoKTfkO+nJP/1X6SMZxkBFOm4CRryBd0cuXqWYYTSzBZBSe2IV/QyYOrlzOc5ARTruAkb8gXdHLm6g0YTgYE00DBCcwM4TaRcON8ubnc3aT1mH9yMiSYhgpOYGYIt4mEG+cLnvucu3ojhpMRwTRScAIzQ7htJNw4X3Aud67emOFkTDCNFZzAzBDuLBJunC94vLxw9QqGk4JgKhScwMwQbhsJN84XnMvqO3bCcDIhmCYKTmBmCHfeUu6spdw2Em6cL3hMq343TBlOpgTTVMEJzAzhLlrKPW4pdyy+cb7gZ6e6hjdjOJkRTDMFJzAzhNtEwo3zBa/H3rl6c4aTOcE0V3ACM0O4TSTcOF/wc1md2y8YThYE00LBCcwM4c5ayp23lHsSCTfOF/wtdenqLRlOlgTTUsEJzAzhNi3lHkTCjfMFr39X19lWDCcrgmml4GTVkC/opDrXXDOcrAmmtYKTdUO+4HH+3tXbMJxsCKaNgpMNyIf3caRy+aU7J/D3nzy/PD69Jqh1wfMj8LyDhLj2D/T3iPd7ePg+uM6v76Bafhv3B/47N3+6J4MnAAA=","debug_symbols":"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","file_map":{"33":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\nmod meta;\nmod append;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"57":{"source":"// use dep::zkemail::{\n//     KEY_LIMBS_2048, dkim::verify_dkim_2048, get_body_hash_by_index, base64::body_hash_base64_decode,\n//     partial_hash::partial_sha256_var_end, standard_outputs\n// };\n\n// global MAX_EMAIL_HEADER_LENGTH: u32 = 512;\n// global MAX_PARTIAL_EMAIL_BODY_LENGTH: u32 = 192;\n\n// fn main(\n//     body_hash_index: u32,\n//     header: [u8; MAX_EMAIL_HEADER_LENGTH],\n//     header_length: u32,\n//     body: [u8; MAX_PARTIAL_EMAIL_BODY_LENGTH], // use partial body length instead of full body length\n//     body_length: u32,\n//     partial_body_hash: [u32; 8],\n//     partial_body_length: u32,\n//     pubkey: [Field; KEY_LIMBS_2048],\n//     pubkey_redc: [Field; KEY_LIMBS_2048],\n//     signature: [Field; KEY_LIMBS_2048]\n// ) -> pub [Field; 2] {\n//     // check the body and header lengths are within bounds\n//     assert(header_length <= MAX_EMAIL_HEADER_LENGTH, \"Email header length exceeds maximum length\");\n//     assert(partial_body_length <= MAX_PARTIAL_EMAIL_BODY_LENGTH, \"Partial email body length exceeds maximum length\");\n    \n//     // verify the dkim signature over the header\n//     verify_dkim_2048(header, header_length, pubkey, pubkey_redc, signature);\n\n//     // manually extract the body hash from the header\n//     let body_hash_encoded = get_body_hash_by_index(header, body_hash_index);\n//     let signed_body_hash: [u8; 32] = body_hash_base64_decode(body_hash_encoded);\n\n//     // finish the partial hash\n//     let computed_body_hash = partial_sha256_var_end(partial_body_hash, body, partial_body_length as u64, body_length as u64);    \n\n//     // check the body hashes match\n//     assert(\n//         signed_body_hash == computed_body_hash, \"Sha256 hash computed over body does not match DKIM-signed header\"\n//     );\n\n//     // hash the pubkey and signature for the standard outputs\n//     standard_outputs(pubkey, signature)\n// }\n\nuse dep::std;\n\nfn main() {\n    for i in 0..5 {\n        std::println(i);\n    }\n\n}\n\nunconstrained fn break_and_continue() {\n    for i in 0..10 {\n        if i==1 {\n            std::println(i);\n            continue;\n        }\n        else if i%2==0 {\n            std::println(i);\n            continue;\n        }\n        else {\n            std::println(i);\n            std::println(\"breaking\");\n            break;\n        }\n    }\n}","path":"/Users/catmcgee/Documents/Work/saoirse/circuits/email_sexual_health/src/main.nr"}},"names":["main"]}